* 자바스크립트는 동적으로 콘텐츠를 바꾸고, 멀티미디어를 제어하고, 애니메이션을 추가하는 등 거의 모든 것을 만들 수 있는 스크립팅 언어이다.
* 자바스크립트는 가볍고, 인터프리터를 사용하는 프로그래밍 언어이다.(인터프리터를 사용하는 언어에서는 코드를 위에서 아래로 실행하고, 코드 구동 결과는 즉시 반환된다., 또한 코드를 실행하기 전에 다른 형태로 변환할 필요가 없는데
프로그래머가 읽을 수 있는 형태로 입력되고, 별도의 처리 없이 그대로 실행된다.)
* 수정하려는 HTML과 CSS코드보다 JavaScript를 먼저 불러와 실행하면 오류가ㅣ 발생할 수 있다.
* 함수 
- var mz = 'mozilla';
mz.indexOf('z'); // ()의 것이 포함되어있는지 알 수 있다.
결과는 2

- spilt() // 문자열을 분리하여 배열로 표현해준다.
var data = 'Manchester,London,Liverpool,Birmingham,Leeds,Carlisle';
var dataArr = data.split(',');
결과는 dataArr[0] ==> Manchester

- join() // 배열을 다시 문자열로 만들 수 있다.
dataArr.join(',');

- toString() // 배열을 문자열로 변환하는 또 다른 방법
join()과 달리 매개변수가 필요없음. 항상 ','를 사용




## 자바스크립트는 버전별로 어떻게 변화하고 발전해 왔을까요?
* 자바스크립트는 1990년대 Netscape회사에 의해 최초로 개발되었다. MS사에서 JScript를 사용하면서 크로스브라우징 이슈가 붉어졌고 자바스크립트의 표준화의 필요성이 대두되었다. 그렇게 1997년 ECMA-262란 이름으로 자바스크립트 기술 규격이 채택되었다.
* 

### 자바스크립트의 버전들을 가리키는 ES5, ES6, ES2016, ES2017 등은 무엇을 이야기할까요?
* ES(ECMAScript)는 자바스크립트를 표준화하기 위해 만들어진 ECMA-262기술 규격에 따라 정의하고 있는 자바스크립트 표준 사양이다.


### 자바스크립트의 표준은 어떻게 제정될까요?
* `TC39`는 **자바스크립트의 표준 명세인 ECMAScript의 명세**들을 논의하고 표준을 제정하는 실질적인 기구이다.  
표준 명세는 단순히 TC39 내의 결정을 통해서만 이루어지진 않는다.

>**0단계** - (TC39의 위원이 아니라도)누구라도 고려한 가치가 있다고 생각하는 아이디어를 제출할 수 있다.  
>↓  
>**1단계(제안)** -  제안이 더 연구되기로 합의가 이루어지면 커뮤니티 구성원들이 토론하고 개발하여 기술을 연구하고 아이디어를 구체화한다.  
>↓  
>**2단계(초안)** - 1단계가 준비가 되면 TC39 회의에 1단계 제안을 제출한다. 커뮤니티가 정확한 구문, 의미 체계, API등을 구체화하고 공식 사양 언어를 사용하여 해결 방법을 자세히 설명한다. 실제로 사용하면서 테스트 할 수 
있도록 폴리필(변경된 표준을 준수할 수 있게 기존 함수의 동작 방식을 수정하거나, 새롭게 구현한 함수의 스크립트)이 생성되기도 한다.      
>↓  
>**3단계(후보)** - 최종 초안이 제출된다. 이는 제안이 자바스크립트 엔진에서 구현될 준비가 되어 있다는 합의가 이루어졌다는 의미이다. 이 단계에서 제안 자체는 거의 변경되지 않고, 구현 중 나온 피드백이 반영되기도 한다.  
>↓  
>**4단계(완료)** - 기능이 완료된 상태이며, 두개 이상의 별개의 호환 구현에서 TC39의 인수 테스트를 통과해야한다. 이 기준을 충족하고 ECMAScript 편집자 그룹이 이를 수락하면 완료된다.  
<br>
이런 과정을 통해 제안이 자바스크립트 표준에 들어가는데, 모든 변경이 이런 과정을 거치는 것은 아니고 작은
변경사항 정도는 TC39에서 합의하여 변경할 수 있다. 

***

## 자바스크립트의 문법은 다른 언어들과 비교해 어떤 특징이 있을까요?

### 자바스크립트에서 반복문을 돌리는 방법은 어떤 것들이 있을까요?
1. for문
    * 
    * for(초기화식; 종료 조건; 증감식){  
        // 실행할 코드  
    }  
2. while문
    *
    * 초기화식   
    while(종료 조건){  
        // 실행할 코드  
        증감식  
    }  
3. do...while문
    *
    * 초기화식
    do{
        // 실행할 코드
        증감식
    } while(종료 조건)

* 반복문들은 대체로 서로 교체할 수 있는데, 각각의 문제와 선호에 맞게 사용하면 될 듯하다.
* 반복문을 종료하고 싶을 때 `break`
    * `break`문은 즉시 반복문을 종료하고 브라우저가 반복문 뒤에 있는 코드로 이동하게 한다.
* 반복문 건너띄기
    * `continue`문은 `break`와 유사하지만 반복문을 완전히 탈출하는 것이 아니라 반복문의 다음 반복으로 건너띈다.

***
## 자바스크립트를 통해 DOM 객체에 CSS Class를 주거나 없애려면 어떻게 해야 하나요?
1. getElementById(), getElementsByClassName() 등과 같은 메소드를 이용하여 요소를 특정하고 아래와 같은 메소드들을 이용하여 추가, 삭제한다.
<table>
    <tr><th>.classList.add('클래스명')</th><td>새로운 클래스 값을 추가한다.</td></tr>
    <tr><th>.classList.remove('클래스명')</th><td>기존의 클래스 값을 삭제한다.</td></tr>
    <tr><th>.classList.toggle('클래스명)</th><td>클래스 값이 추가되었다 삭제되도록 한다.</td></tr>
    <tr><th>.classList.replace('기존 클래스명', '새 클래스명')</th><td>특정 클래스 값을 다른 클래스 값으로 교체한다.</td></tr>
</table>

`ex) document.getElementById('a').classList.add('클래스명');`  
`ex) document.getElementById('a').classList.remove('클래스명');`

2. DOM 객체를 특정하고 setAttribute() 메소드를 이용하여 class 속성을 생성해준 후 클래스명을 추가, 삭제한다.  
`ex) document.getElementById('a').setAttribute('class', '클래스명');`  
`ex) document.getElementById('a').setAttribute('class', '');`

3. DOM 객체를 특정하고 className을 이용하여 클래스명 추가, 삭제한다.
`ex) document.getElementById('a').className = '클래스명, 클래스명, 클래스명'`  
+= 연산자를 사용하여 추가하기    
`ex) document.getElementById('a').className += ' 클래스명'`

+ DOM 객체를 이용한 CSS스타일 변경
1. DOM 객체를 특정하고 style.property를 이용하여 CSS를 변경한다.  
    * property에는 backgroundColor, color, position, width 값 등이 있다.
`ex) document.getElementById('a').style.속성 = '새 스타일'`
2. 스타일시트 활성화와 비활성화
`ex) document.getElementById('b').disabled = true` ==> `b`라는 id명을 가진 스타일시트가 비활성화된다.  
`ex) document.getElementById('b').disabled = false` ==> `b`라는 id명을 가진 스타일시트가 활성화된다.


### IE9나 그 이전의 옛날 브라우저들에서는 어떻게 해야 하나요?
***

## 자바스크립트의 변수가 유효한 범위는 어떻게 결정되나요?
* 자바스크립트에서 변수는 유효 범위에 따라 **지역 변수**와 **전역 변수**로 구분된다.
* 보통 `{}중괄호`가 기준이 되어 구불할 수 있다.
* 지역 변수와 전역 변수를 구분하면 변수 이름이 중복됐을 때, 같은 이름을 가진 변수라도 상황에 따라 각각 다르게 사용될 수 있다는 장점이 있다.
<br>

1. **지역 변수** 
    * 지역 변수란 함수 내에서 선언된 변수를 가리킨다.
    * 변수가 선언된 함수 내에서만 유효하며, 함수가 종료되면 메모리에서 사라진다.
    * 함수의 매개변수도 함수 내에서 정의되는 지역 변수처럼 동작한다.
2. **전역 변수**
    * 전역 변수란 함수의 외부에서 선언된 변수를 가리킨다.
    * 프로그램의 어느 영역에서나 접근할 수 있으며, 웹페이지가 닫혀야만 메모리에서 사라진다.
<br>

* 지역 변수를 선언할 때에는 반드시 var, let 키워드를 사용하여 선언해야 하는데, 함수 내부에서 var, let 키워드를 사용하지 않고 변수를 선언하면 해당 변수는 지역변수가 아닌 전역 변수로 선언된다.
* 전역변수명과 같은 이름의 변수가 선언된 블록에서 이 변수를 사용한다면, 지역 변수가 우선권을 갖게 된다.
* 전역변수명과 같은 이름의 변수가 선언된 블록에서 전역 변수를 호출하려면 전역 변수가 window 객체의 프로퍼티임을 명시하면 된다. ex) window.변수명

### var과 let으로 변수를 정의하는 방법들은 어떻게 다르게 동작하나요?

* 스코프(scope) =  스코프란 중괄호{}로 둘러쌓인 코드의 영역을 뜻한다. 반드시 중괄호만 스코프를 형성하는 것은 아니고 function의 경우 매개변수가 포함되고, if나 for의 경우 한 줄의 코드만 가질 경우 중괄호 없이도 사용할 수 있다.
<table>
    <tr><th>구분</th><th>var</th><th>let</th></tr>
    <tr><th>스코프</th><td>가장 가까운 function 내부</td><td>가장 가까운 중괄호 내부</td></tr>
    <tr><td colspan="3"> * var는 자신으로부터 가장 가까운 function 스코프 안에서만 사용할 수 있다. 함수의 중괄호를 벗어나면 더 이상 그 변수를 사용할 수 없는 것이다. 같은 function이기만 하면 되어 if나 for안에서 선언된
    변수를 밖에서 사용하는 것도 가능하다.
    * let은 자신으로부터 가장 가까운 블록 스코프 안에서만 사용할 수 있다. for 초기식에서 let으로 선언한 변수는 for 스코프에 속하므로 for 바깥에서 사용할 수 없다. </td></tr>
</table>

* 호이스팅(hoisting) = 모든 변수, 함수의 선언부를 맨 위로 끌어올리는 것이다. 변수 선언보다 변수 호출이 윗 줄에 위치해도 실행되는 기능
<table>
    <tr><th>구분</th><th>var</th><th>let</th></tr>
    <tr><th>스코프</th><td>호이스팅 됨</td><td>호이스팅되지 않음</td></tr>
    <tr><td colspan="3"> * var는 호이스팅이 일어나 var 선언 이전에도 스코프 안이라면 var로 선언된 변수를 사용할 수 있다. 주의할 점은 <b>호이스팅으로 인해 값까지 초기화가 이루어지는 것은 아니기 때문에<b>  
    예를 들어
    ![screenshot](Images/hoisting.png)
    와 같은 결과가 나타난다.
    * let은 호스팅이 일어나지 않아 let 선언 이전에 let으로 선언된 변수를 사용할 수 없다.</td></tr>
</table>

+ 추가 `const`
* let과 const는 변수냐 상수냐의 차이를 제외하곤 모두 같다.
* let의 값은 바꿀 수 있지만 const의 값은 바꿀 수 없다.

    
***
## 자바스크립트의 익명 함수는 무엇인가요?
* 자바스크립트 익명 함수란 따로 함수의 이름을 갖지 않는 함수이다. 재사용하지 않고, 한 번만 사용할 함수를 위한 개념이다.
![screenshot](Images/anonymous.png)
* 함수명 대신 변수명에 함수 코드를 저장하여 사용할 수 있는데, 변수명을 사용해서 함수를 호출하거나 변수값을 이동시킬 수 있다.
* 기본형은 끝에 ';'(세미콜론)을 붙여주어야 한다.
![screenshot](Images/anonymous2.png)
* 특징 
    * 변수값으로 구성된 함수코드를 다른 변수명에 마치 변수를 대입하듯 이동시킬 수 있다.
    * **호이스팅이 적용되지 않는다.**
* 장점
    * 메모리 관리에 효과적인 방안이 될 수 있다.
    * 단 한번만 사용되는 함수의 경우, 미리 호이스팅되어 해당 함수가 사용될 때까지 기다리지 않고 해당 함수가 필요한 위치에서 구현되고 사라지면서 메모리를 아낄 수 있다.

### 자바스크립트의 Arrow function은 무엇일까요?
* 자바스크립트의 화살표함수란 화살표(=>)를 사용하여 일반 함수 표현식보다 단순하고 간결한 문법으로 함수를 만드는 방식이다.
![screenshot](Images/arrow.png)
* 특징
    * 화살표 함수는 익명 함수로만 사용할 수 있다.
    * 콜백 함수(다른 함수의 인자로써 이용되는 함수)로 사용할 수 있다. 
    ![screenshot](Images/callback.png)
    * this와 argument가 없다 ==> 화살표 함수의 `this`는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되므로, 언제나 상위 스코프의 this를 가리킨다. 
* 화살표 함수를 쓰지 않아야 할 때
    1. 화살표 함수로 메소드를 정의하는 것은 피해야 한다.
        * 메소드로 정의한 화살표 함수 내부의 `this`는 메소드를 소유한 객체를 가리키지 않고 상위 객체를 가리키므로 바람직하지 않다.
    2. prototype 메소드
        * 화살표 함수로 정의된 메소드를 prototype에 할당하는 경우도 1번과 같은 문제가 발생한다.
    3. new 생성자 함수
        * 화살표 함수는 생성자 함수로 사용할 수 없다.
        * 생성자 함수는 prototype 프로퍼티를 가지며 프로토타입 객체의 constructor를 사용하는데, 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다.
    4. addEventListener 함수의 콜백 함수
        * addEventListener 함수의 콜백함수를 화살표 함수로 정의하면 `this`가 상위 객체 window를 가리키게 된다.
    5. call, apply, bind 메소드를 사용하여 `this`를 변경할 수 없다.
