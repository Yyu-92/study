## HTML 표준의 역사는 어떻게 될까요?
>SGML을 바탕으로 HTML1.0이 등장 : 표현할 수 있는 데이터가 제한적이고, 텍스트 위주의 작성  
>`&darr;`    
>W3C가 출현하여 웹 표준을 정의  
>`&darr;`    
>더 많은 정보표현의 요구와 실용적인 태그가 등장하면서 HTML2.0~HTML3.2 버전 출시  
>`&darr;`    
>CSS로 디자인적인 요소를 구분하는 HTML4.01 버전이 출시 : HTML로 웹페이지 전반적인 구조만을 명시. HTML의 안정기라 불림  
>`&darr;`    
>W3C가 새로운 웹 표준으로 삼기 위해 XHTML 개발 : 더욱 확장된 태그를 사용할 수 있다.  
>`&darr;`    
>XHTML의 엄격한 문법구조와 하위버전 호환에 대한 한계로 사용자들의 외면을 받게 되면서 WHATWG에서 HTML5를 출시  
>`&darr;`  
>W3C에서 XHTML2.0 개발을 중단하고 HTML5를 웹표준으로 발표  

### HTML 표준을 지키는 것은 왜 중요할까요?
* 글을 쓸 때 문법에 맞지 않아도 의미가 통할 수 있는 것처럼 html 역시 정해진 문법에 정확히 맞지 않아도 웹브라우저에서 적절하게 해석하여 표현해 주기도 한다. 그러나 이러한 것들은 웹브라우저마다 동일한 것은 아니기 때문에 html의 표준을 지켜 서비스를 제공하게 되면 사용자가 어떤 환경(어떤 브라우저)에서 접속하든 같은 화면과 정보를 전달해 줄 수 있다. 
* html표준을 지켜 작성하게 되면 화면리더기 등을 통해 시각장애인, 청각장애인 등 모두에게 차별없는 접근이 가능하게 한다.
* 검색엔진에 최적화되어 효율적인 검색 결과를 나타낸다.

### XHTML2.0은 왜 세상에 나오지 못하게 되었을까요?
* XHTML은 W3C가 HTML은 다양한 웹페이지를 표현하기에 기술적인 한계에 부딪혔다고 판단하고 표준으로 삼으려한 언어로, XML과 HTML을 합성하여 더 확장된 태그를 사용할 수 있게 하는 언어이다. 
* 그러나 아래와 같은 단점들로 인해 사용자들의 외면을 받게 되고 HTML4.01버전으로 회귀하기 시작하여 버려지게 된다.
    1. XHTML은 버전사이의 하위 호환성을 지원하지 않아 이전 태그들로 작성된 것들이 사용되지 않을 수 있다.
    2. 엄격한 태그 작성을 중요시하여 개발자들이 습득에 어려움을 겪음.
    3. 잘못된 문법일 경우 페이지가 표시되지 않음.
    4. 웹에서 애플리케이션을 동작하기 위해서는 active-x나 flash player등 별도의 프로그램들을 설치해야하는 불편함이 있음.

### HTML5 표준은 어떤 과정을 통해 정해질까요?
* W3C에서 XHTML을 표준으로 삼으려 하자, 당시 대중적인 브라우저를 가지고 있던 기업들이 추진
* W3C는 World Wide Web의 주요 국제 표준 조직으로 이해관계를 가진 수백 기관, 기업이 회원으로 가입되어 웹표준을 협의, 정의하는 컨소시엄 조직이다.
* 초안 : 충분한 의견을 수집 후 커뮤니티에 게시      
-> 후보 권고안 : 피드백을 받은 권고안. 얼마나 표현 가능한지 검토하고 중요한 기능들이 대부분 결정됨.  
-> 제안 권고안 : 초안과 검토를 통과한 권고안. 제안 권고안이 W3C자문 위원회에 제출됨.  
-> W3C 추천 : 광범위한 검토 및 테스트를 거쳐 W3C에서 승인하여 대중에 배포됨.  
   
***

## 브라우저의 역사는 어떻게 될까요?
* 1993년 그래픽을 지원하는 웹 브라우저 모자이크가 등장하면서 1990년대 웹붐이 일어남  
-> 모자이크 팀의 marc andreessen이 따로 회사를 차려 넷스케이프를 출시. 한 때 점유율이 90%에 달할 정도로 인기를 끌었다.  
-> 그 후 여러 브라우저들이 출시되고, 마이크로소프트가 윈도우즈 운영체제에 인터넷 익스플로러를 무료로 탑재하면서 경쟁하게 됨  
-> 2000년대 초 인터넷 익스플로러의 브라우저 시장 점유율이 90% 이상을 상회하면서 웹브라우저의 표준으로 자리잡음  
-> 넷스케이프에서 푼 오픈소스를 바탕으로 모질라가 파이어폭스를 출시  
-> 사파리와 크롬이 출시
-> 인터넷 익스플로러는 웹표준 호환성 문제와 보안 취약성등을 이후로 내리막길을 걷게 되고, 크롬, 사파이, 파이어폭스등에 밀리게 된다.  
-> 마이크로소프트는 2015년 엣지를 출시하고 네이버에서 웨일을 출시

### Internet Explorer가 브라우저 시장을 독점하면서 어떤 문제가 일어났고, 이 문제는 어떻게 해결되었을까요?
* Internet Explorer의 브라우저 시장 독점은 한 때 90%의 점유율에 이르기까지 했는데, 그렇게 브라우저 시장을 독점체제가 굳어지면서 마이크로소프트는 Internet Explorer의 기능 개선에 힘을 쓰지 않았고 2001년 버전 6을 출시한 이후 5년간 단 2번의 서비스 팩 업데이트만을 선보였다. 기술의 발전이 이루어 지지 않고 있는 것이다. 이로 인해 웹표준 HTML5와의 호환성 문제 또는 각종 보안문제 대응에 대한 문제가 일어났다. 또한 모바일 시대의 도래에도 불구하고 모바일용 브라우저를 출시하지 않는 등 사용자들의 이탈을 발생시켰다. 모바일 시장에 발맞춘 크롬과 사파리의 점유율이 빠른 속도로 증가하면서 인터넷 익스플로러가 몰락하게 되었다.

### 현재 시점에 브라우저별 점유율은 어떻게 될까요? 이 브라우저별 점유율을 알아보는 것은 왜 중요할까요?
* 현재 크롬 65.7%, 사파리 18.66%, 엣지 4.32%, 파이어폭스 3.14%, 삼성인터넷 2.75%, 오페라 2.25%의 점유율을 보이고 있다.
* 국내 시장에서는 데스크탑 기준으로 크롬 71.63%, 엣지 16.01%, 웨일 5.78%의 점유율을 보인다.
* 웹브라우저는 빅데이터 사업에서 중요한 위치를 점하고 있다. 최근 인터넷 플랫폼은 사물인터넷 기술의 확대로 PC와 모바일을 넘어 자동차나 공장 등 모든 공간과 사물이 플랫폼이 되어 확장되고 있다. 이런 상황에서 웹브라우저는 사용자와 연결되는 프로그램이며, 브라우저의 점유율이 높아질수록 경쟁에서 우위를 차지할 수 있다.
* 다양한 브라우저가 사용되면서 뷰나 기능 동작과 같은 부분에서 각 브라우저간의 호환성에 대한 문제가 발생한다. 각 브라우저마다 지원하는 기능의 여부가 다르기 때문에 개발자는 다양한 브라우저 환경에 대한 기술 지원을 고민해야 한다. 웹 표준과 개발사를 중심으로 이를 해결하기 위한 노력이 계속되고 있지만, 각 브라우저간의 특성이 완전히 같을 순 없으므로 개발자들은 특정 브라우저가 사용하려는 기능을 지원하지 않을시 이 기능의 사용여부를 선택해야 하는데, 이때 브라우저의 시장점유율과 사용하려는 기술의 중요도를 비교하게 된다. 그 둘의 경중을 비교하여 가장 합리적인 방향으로 웹서비스를 제공해야하기 때문에 브라우저 점유율을 알아보는 것이 중요하다.

### 브라우저 엔진(렌더링 엔진)이란 무엇일까요? 어떤 브라우저들이 어떤 엔진을 쓸까요?
* 브라우저 엔진이란 HTML문서와 기타 자원의 웹페이지를 사용자의 장치에 시각적으로 변환시켜주는 것이다.
* 브라우저가 서버로부터 HTML 문서를 전달받으면 브라우저 엔진은 이를 파싱하여 DOM트리를 구축하고 스타일요소와 함께 파싱한다. DOM트리와 스타일요소를 파싱한 것을 합쳐 렌더 트리를 구축하고 렌더 트리의 각 노드에 대해서 화면 상 어디에 배치할 지 결정한다. 이렇게 결정된 것들이 화면으로 출력된다.
* 브라우저별 엔진

|브라우저|파이어폭스|크롬|오페라|인터넷 익스플로러|사파리|엣지|
|---|---|---|---|---|---|---|
|**엔진**|게코|블링크|블링크|트라이던트|웹키트|블링크|

### 모바일 시대 이후, 최근에 출시된 브라우저들은 어떤 특징을 가지고 있을까요?
* 디바이스 별로 반응형 뷰를 제공하는 브라우저들, 모바일에서도 잘돌아가야하기 때문에 가볍고 작은 화면에서 효율적으로 웹 콘텐츠를보여주는데 최적화

***

## HTML 문서는 어떤 구조로 이루어져 있나요?
1. `<!doctype>`으로 문서유형을 지정하는 선언을 하면서 시작
2. `<html>` - `</html>` 으로 웹페이지의 시작과 끝을 알린다. HTML로 작성된 모든 내용은 2번 사이에 있어야한다. 여는 `<html>`태그 안에 페이지의 언어를 설정할 수도 있다.
3. `<head>` - `</head>` 2번의 사이 상단에 작성하고 웹문서를 해석하기 위한 메타데이터 정보(ex. meta, style, title)들을 입력한다. 
4. `<body>` - `</body>` 실제로 화면에 나타내고자 하는 내용들을 작성한다.
5. 4번 사이에 h태그, p태그, div태그, span태그 등 각 알맞는 태그들을 이용하고 컨텐츠들을 작성하다.

### `<head>`에 자주 들어가는 엘리먼트들은 어떤 것이 있고, 어떤 역할을 할까요?
* `<head>`에는 해당 페이지의 메타데이터가 포함된다. 이 메타데이터들은 해당 페이지의 문서 정보를 담고 있다.
* `<head>`에 들어가는 엘리먼트

|**title**|문서 제목을 나타내는 것으로 브라우저의 제목 표시줄이나 페이지 탭에 보인다.|
|**charset**|페이지의 문자 인코딩을 선언한다.|
|**name**|name을 통해 meta정보의 형태를 알려주고 keywords, description, robots등으로 지정하여 해당 문서의 키워드나 설명 혹은 로봇의 검색범위등을 지정할 수 있다.|
|**link**|link를 이용해 스타일시트를 연결할 수 있고, 파비콘, 아이콘등을 연결할 수 있다.|
|**script**|script를 이용해 자바스크립트를 연결할 수 있다.|

### 시맨틱 태그는 무엇일까요?
* 시맨틱 태그는 의미론적 마크업을 하는 것으로 태그 자체에 의미가 담겨 전달할 수 있다.
* 제목을 의미하는 `<h1>`과 폰트 사이즈를 `<h1>`의 크기만큼 키운 `<p>`는 시각적으론 같아 보이지만 같은 의미를 가졌다고 볼 순 없다.

#### 시맨틱 엘리먼트를 사용하면 어떤 점이 좋을까요?
1. 좋은 시맨틱 HTML은 웹문서의 접근성을 향상시킨다. 예를 들어 시각장애가 있는 사용자가 이용할 때 의미론적 마크업을 푯말로 사용하여 더욱 쉽게 컨텐츠를 찾고 이용할 수 있게 한다. 따라서 모두가 최대한 공평하게 이용할 수 있게 된다.
2. 검색엔진이 웹문서를 검색하고 찾아내는데 영향을 미친다. 효과적으로 컨텐츠의 의미를 전달하여 효과적인 크롤링과 인덱싱을 할 수 있게 한다. 
3. 시맨틱 태그를 사용함으로써 개발자가 자신이 의도하는 바를 잘 나타낼 수 있고, 사용자도 태그만을 보고 컨텐츠를 유추할 수 있다. 또한 해당 컨텐츠를 찾는데 유리하게 작용할 수 있다.

#### `<section>`과 `<div>`, `<header>`, `<footer>`, `<article>` 엘리먼트의 차이점은 무엇인가요?
* `<section>`과 `<div>`는 의미론적인 부분에서 차이가 있다. 아무런 의미없이 컨텐츠를 시각적으로 묶어주기만 하는 `<div>`와는 달리 `<section>`은 컨텐츠를 논리적으로 관계 있는 문서끼리 묶어서 모아주고 분리시켜주는데(=주제별로 묶음) 사용된다.
* `<article>`은 제목과 내용 문단으로 이루어진 컨텐츠를 묶는데 사용된다. 이는 독립적으로 배포하거나 완전한 하나의 컨텐츠로 이용될 수 있다.(ex. 블로그의 포스트, 뉴스 기사)
* `<section>`과 `<article>`중 `<section>`이 더 큰 의미라고 보면 될 듯하다.
* `<header>`는 주로 웹문서의 가장 상단에 보여지는 부분으로 웹사이트의 제목, 로고, 검색창 및 `<nav>`태그로 표현되는 사이트 메뉴 등이 포함된다.
* `<footer>`는 주로 웹 문서의 가장 하단에 보여지는 부분으로 웹사이트의 정보나, 저작권 정보 등이 포함된다.

#### 블록 레벨 엘리먼트와 인라인 엘리먼트는 어떤 차이가 있을까요?
* 블록 레벨 엘리먼트는 일반적으로 페이지의 구조적 요소(단락, 목록 등)를 나타낼 때 사용되고, 인라인 엘리먼트는 항상 블록레벨 엘리먼트 안에 포함되어 사용되어 진다. 블록 요소는 인라인 요소보다 더 큰 구조를 생성할 수 있고, 인라인요소는 구조 크기에 영향을 주지 않고 컨텐츠에 속성따위를 주기 위해 사용되는 것으로 이해된다.
* 인라인 요소는 블록 요소를 감쌀 수 없다.
* 블록 요소는 한줄을 차지하므로 요소 사이에 줄바꿈이 일어나고, 인라인 요소는 딱 컨텐츠의 크기만큼만 차지하므로 줄바꿈이 일어나지 않아 다음 컨텐츠의 속성에 따라 옆으로 붙기도 한다.
* 블록 요소는 넓이, 높이 값을 지정 할 수 있고, 인라인 요소는 넓이, 높이와 상하마진값을 지정할 수 없다.





